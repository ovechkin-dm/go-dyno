{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Go-dyno","text":""},{"location":"#quick-start","title":"Quick start","text":"<p>Install latest version of the library using go get command:</p> Bash<pre><code>go get -u github.com/ovechkin-dm/go-dyno\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>This is an example of proxy that prints method name before any method invocation of the original instance. </p> Go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n\n    \"github.com/ovechkin-dm/go-dyno/pkg/dyno\"\n)\n\ntype Greeter interface {\n    Greet() string\n    SayHello(name string) string\n}\n\ntype SimpleGreeter struct {\n\n}\n\nfunc (g *SimpleGreeter) Greet() string {\n    return \"Hello!\"\n}\n\nfunc (g *SimpleGreeter) SayHello(name string) string {\n    return fmt.Sprintf(\"Hello, %s!\", name)\n}\n\ntype ProxyHandler[T any] struct {\n    Impl T\n}\n\nfunc (p *ProxyHandler[T]) Handle(m reflect.Method, values []reflect.Value) []reflect.Value {\n    fmt.Println(\"Method called:\", m.Name)\n    return reflect.ValueOf(p.Impl).MethodByName(m.Name).Call(values)    \n}\n\n\n\nfunc main() {   \n    greeter := &amp;SimpleGreeter{}\n    proxyHandler := &amp;ProxyHandler[Greeter]{Impl: greeter}\n    dynamicGreeter, err := dyno.Dynamic[Greeter](proxyHandler.Handle)\n    if err != nil {\n        fmt.Println(\"Error creating dynamic greeter:\", err)\n        return\n    }\n\n    fmt.Println(dynamicGreeter.Greet())\n    fmt.Println(dynamicGreeter.SayHello(\"World\"))\n}\n</code></pre>"},{"location":"examples/","title":"Examples","text":""},{"location":"examples/#simple-stopwatch","title":"Simple stopwatch","text":"<p>An example of a proxy that measures and prints time taken for every method invocation:</p> Go<pre><code>package main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n    \"time\"\n\n    \"github.com/ovechkin-dm/go-dyno/pkg/dyno\"\n)\n\ntype Greeter interface {\n    Greet() string\n    SayHello(name string) string\n}\n\ntype SimpleGreeter struct {\n\n}\n\nfunc (g *SimpleGreeter) Greet() string {\n    return \"Hello!\"\n}\n\nfunc (g *SimpleGreeter) SayHello(name string) string {\n    return fmt.Sprintf(\"Hello, %s!\", name)\n}\n\ntype StopWatch[T any] struct {\n    Impl T\n}\n\nfunc (p *StopWatch[T]) Handle(m reflect.Method, values []reflect.Value) []reflect.Value {\n    before := time.Now()\n    result := reflect.ValueOf(p.Impl).MethodByName(m.Name).Call(values) \n    after := time.Now()\n    fmt.Printf(\"Method %s took %v\\n\", m.Name, after.Sub(before))\n    return result\n}\n\n\n\nfunc main() {   \n    greeter := &amp;SimpleGreeter{}\n    stopWatch := &amp;StopWatch[Greeter]{Impl: greeter}\n    dynamicGreeter, err := dyno.Dynamic[Greeter](stopWatch.Handle)\n    if err != nil {\n        fmt.Println(\"Error creating dynamic greeter:\", err)\n        return\n    }\n\n    fmt.Println(dynamicGreeter.Greet())\n    fmt.Println(dynamicGreeter.SayHello(\"World\"))\n}\n</code></pre>"},{"location":"internals/","title":"Library internals and guarantees","text":"<p>This section is describing undocumented/unexposed golang runtime features, that the library relies on. It is important to keep these features documented, as the golang runtime is a subject to change. Users of the library need more transparency, because of the (unlikely) possibility that this library won't be able to run on later golang versions. </p>"},{"location":"internals/#golinkname","title":"go:linkname","text":"<p>Relies on:</p> <p>//go:linkname directive in golang linker. </p> <p>Will be changed: </p> <p>Highly unlikely</p> <p>Workaround:</p> <p>Unknown (needs investigation)</p> <p>Description:</p> <p>With the introduction of go 1.23, directive //go:linkname was mostly removed. https://tip.golang.org/doc/go1.23#linker After release of go1.23, users of the language were only allowed to link to a limited set of function in golang runtime. Go-dyno uses only one such function, that is allowed to be linked:</p> Go<pre><code>//go:linkname addReflectOff reflect.addReflectOff\nfunc addReflectOff(ptr unsafe.Pointer) int32\n</code></pre> <p>There is no evidence that linking for this function will be removed.</p> <p>In the unlikely case this feature will be removed, we have to find a way to set function address for dynamically created struct.</p>"},{"location":"internals/#internal-go-runtime-structures","title":"Internal go runtime structures","text":"<p>Relies on:</p> <p><code>rtype</code>, <code>structTypeUncommon</code> structure layout</p> <p>Will be changed: </p> <p>Likely</p> <p>Workaround:</p> <p>Easy</p> <p>Description:</p> <p>Consider current struct:</p> Text Only<pre><code>type refValue struct {\n    typ  *rtype\n    ptr  unsafe.Pointer\n    flag uintptr\n}\n</code></pre> <p>It contains the same field that are inside go runtime <code>refValue</code> struct. However if golang runtime will change struct and, for example, add one more field in the beginning of fields declaration, this will break binary compatibility and we have to reflect the change in our struct also. The change itself is not hard and can easily be fixed.</p>"},{"location":"internals/#golang-abi","title":"Golang ABI","text":"<p>Relies on:</p> <p>Current golang ABI (Application Binary Interface)</p> <p>Will be changed: </p> <p>Likely</p> <p>Workaround:</p> <p>Easy</p> <p>Description:</p> <p>Current implementation heavily relies on golang ABI specification which includes:</p> <ul> <li>Register layout</li> <li>Receiver register</li> <li>Function call layout with receiver VS without receiver</li> <li>Others</li> </ul> <p>we can adapt the library to accommodate the changes. The golang team provides detailed release notes and documentation for any ABI modifications, which will allow us to update the implementation accordingly. Since the changes are typically incremental and well-documented, we are confident that any necessary adjustments can be made with minimal disruption to the library's functionality.</p>"},{"location":"limitations/","title":"Limitations","text":"<p>Because library uses assembly code to create proxy, it relies on CPU architecture ABI.  This means that you cannot use it in a project that is intended to be cross-compiled to platforms other than ones that are listed below.</p> <p>For now supported platforms are:</p> <ul> <li>AMD64</li> <li>ARM64 (M1-M3 macs are supported)</li> </ul> <p>This list may be extended in the future.</p>"},{"location":"supported-go-versions/","title":"Supported GO versions","text":""},{"location":"supported-go-versions/#go-117","title":"Go *-1.17","text":"<p>The library does not support Go versions before and up to 1.17 because it relies on generics support. Additionally, Go 1.17 still uses the stack instead of registers for function argument allocation. If you are still interested in having a dynamic proxy for Go 1.17, take a look at dpig.</p>"},{"location":"supported-go-versions/#go-118-124","title":"Go 1.18-1.24","text":"<p>Fully supported for ARM64/AMD64 architectures. For other limitations, please refer to the \"Limitations\" section.</p>"},{"location":"supported-go-versions/#future-go-versions","title":"Future Go Versions","text":"<p>Although future Go versions should support the library without any changes, there is still a chance that something in the Go runtime may change. Please refer to the \"Library Internals and Guarantees\" section for more information.</p>"}]}